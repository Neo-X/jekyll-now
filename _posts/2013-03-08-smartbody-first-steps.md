---
layout: post
title: SmartBody, first steps
date: '2013-03-08T08:06:00.001-08:00'
author: Glen B
tags: 
modified_time: '2013-03-08T08:06:47.857-08:00'
blogger_id: tag:blogger.com,1999:blog-2030049895335802245.post-2626671259543171982
blogger_orig_url: http://fracturedplane.blogspot.com/2013/03/smartbody-first-steps.html
---

<br /><a href="http://smartbody.ict.usc.edu/">SmartBody</a> is a character animation platform originally developed at the <a href="http://usc.edu/">University of Southern California</a> <a href="http://ict.usc.edu/">Institute for Creative Technologies</a>.&nbsp;SmartBody provides locomotion, steering, object manipulation, lip syncing, gazing and nonverbal behavior in real time.<br />SmartBody is written in C++ and can be incorporated into most game  and simulation engines.&nbsp;SmartBody is a Behavioral Markup Language (BML)  realization engine that transforms BML behavior descriptions into  realtime animations.&nbsp;SmartBody runs on Windows, Linux, OSx as well as  the iPhone and Android devices.<br /><br />I want to use this to control the character animations for a video game made in Unity3D.<br /><br />&nbsp;The package does say this it can work with<br /><ul><li>Unity</li><li>Ogre</li><li>Unreal</li><li>Panda3D</li><li>GameBryo</li></ul>However it supports Unity and Ogre actively.&nbsp; <br /><br />Goal: To send BML messages to a control characters in SmartBody via TCP or UDP messages.<br /><br />Tasks:<br /><ol><li><a href="http://fracturedplane.blogspot.ca/2013/02/get-and-compile-smart-body.html" target="_blank">Get and Compile SmartBody ( For Windows and Linux )</a></li><li><a href="http://fracturedplane.blogspot.ca/2013/03/smartbody-example.html" target="_blank">Familiarize self with SmartBody examples</a></li><li><a href="http://fracturedplane.blogspot.ca/2013/02/python-and-tcpip.html" target="_blank">Learn how to use TCP in Python.</a></li><li>Produce code to control SmartBody character from python code combining what was learned from 2 and 3.<br /><br /><br /><pre class="prettyprint"><code class="language-py"><br />import random<br /><br />import select<br />import socket<br />import sys<br /><br />service = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br /><br /># Connect the socket to the port where the server is listening<br />server_address = ('localhost', 3850)<br />print &gt;&gt; sys.stderr, 'connecting to %s port %s' % server_address<br />service.connect(server_address)<br /><br /><br />print "|--------------------------------------------|"<br />print "|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Starting Locomotion Type Demo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |"<br />print "|--------------------------------------------|"<br /><br />smartBodyRelitivePath = "../../smartbody/data/"<br /><br /># Add asset paths<br />scene.addAssetPath('script',smartBodyRelitivePath + 'sbm-common/scripts')<br />scene.addAssetPath('mesh', smartBodyRelitivePath + 'mesh')<br />scene.addAssetPath('mesh', smartBodyRelitivePath + 'retarget/mesh')<br />scene.addAssetPath('motion', smartBodyRelitivePath + 'ChrBrad')<br />scene.addAssetPath('motion', smartBodyRelitivePath + 'ChrRachel')<br />scene.addAssetPath('motion', smartBodyRelitivePath + 'retarget\motion')<br />scene.addAssetPath('motion', smartBodyRelitivePath + 'sbm-common/common-sk')<br />scene.loadAssets()<br /><br /><br /># Set scene parameters and camera<br />print 'Configuring scene parameters and camera'<br />scene.setScale(1.0)<br />scene.setBoolAttribute('internalAudio', True)<br />scene.run('default-viewer.py')<br />camera = getCamera()<br />camera.setEye(0, 2.87, 11.67)<br />camera.setCenter(0, 2.14, 9.81)<br />camera.setUpVector(SrVec(0, 1, 0))<br />camera.setScale(1)<br />camera.setFov(1.0472)<br />camera.setFarPlane(100)<br />camera.setNearPlane(0.1)<br />camera.setAspectRatio(0.966897)<br />scene.getPawn('camera').setPosition(SrVec(0, -5, 0))<br /><br /># Set joint map for Brad<br />print 'Setting up joint map for Brad'<br />scene.run('zebra2-map.py')<br />zebra2Map = scene.getJointMapManager().getJointMap('zebra2')<br />bradSkeleton = scene.getSkeleton('ChrBrad.sk')<br />zebra2Map.applySkeleton(bradSkeleton)<br />zebra2Map.applyMotionRecurse('ChrBrad')<br /><br /># Retarget setup<br />scene.run('motion-retarget.py')<br /># Animation setup<br />scene.run('init-param-animation.py')<br /><br /># Set up 3 Brads<br />print 'Adding characters into scene'<br />posX = -200<br />for i in range(1): # Only add one brad<br />&nbsp;&nbsp;&nbsp; baseName = 'ChrBrad%s' % i<br />&nbsp;&nbsp;&nbsp; brad = scene.createCharacter(baseName, '')<br />&nbsp;&nbsp;&nbsp; bradSkeleton = scene.createSkeleton('ChrBrad.sk')<br />&nbsp;&nbsp;&nbsp; brad.setSkeleton(bradSkeleton)<br />&nbsp;&nbsp;&nbsp; # Set position<br />&nbsp;&nbsp;&nbsp; bradPos = SrVec((posX + (i * 200))/100, 0, 0)<br />&nbsp;&nbsp;&nbsp; brad.setPosition(bradPos)<br />&nbsp;&nbsp;&nbsp; # Set up standard controllers<br />&nbsp;&nbsp;&nbsp; brad.createStandardControllers()<br />&nbsp;&nbsp;&nbsp; # Set deformable mesh<br />&nbsp;&nbsp;&nbsp; brad.setDoubleAttribute('deformableMeshScale', .01)<br />&nbsp;&nbsp;&nbsp; brad.setStringAttribute('deformableMesh', 'ChrBrad')<br />&nbsp;&nbsp;&nbsp; # Play idle animation<br />&nbsp;&nbsp;&nbsp; bml.execBML(baseName, '<body posture="ChrBrad@Idle01">')<br />&nbsp;&nbsp;&nbsp; # Retarget character<br />&nbsp;&nbsp;&nbsp; retargetCharacter(baseName, 'ChrBrad.sk', False)<br /><br /># Turn on GPU deformable geometry for all<br />for name in scene.getCharacterNames():<br />&nbsp;&nbsp;&nbsp; scene.command("char %s viewer deformableGPU" % name)<br /><br /># Whether character has reached its target<br />brad1Reached = True<br /><br /># Paths for characters<br />brad1Path = [SrVec(-2, 8, 0), SrVec(-2, -8, 0)]<br /><br />bradCur = 0<br />pathAmt = 2<br /><br /><br />class LocomotionDemo(SBScript):<br />&nbsp;&nbsp;&nbsp; def update(self, time):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Select is a creative way of checking to see if a service has data ready to read,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # ready to write to or an exceptional condition.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r, w, e = select.select([service], [], [], 0.0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if r: # There is something to read<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = service.recv(256)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character = 'ChrBrad0'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # The last 0 in the target is zero just so the character stays on the plane<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bmlMessage = '<locomotion manner="jog" target="' + data + ' 0'+ '" type="basic">'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print "BML Message for " + character + ": " + bmlMessage<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bml.execBML(character, bmlMessage)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /><br /># Run the update script<br />scene.removeScript('locomotiondemo')<br />locomotiondemo = LocomotionDemo()<br />scene.addScript('locomotiondemo', locomotiondemo)</locomotion></body><br /></code></pre></li></ol><ol></ol>